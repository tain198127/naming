# coding=utf-8


def generate_name(name_dim):
    """
    生成一些名字，进行组合。这里是最核心的算法。
    模型算法规则：
    随机选两个字，按照如下规则进行计算打分
    1. 若两个名字在一句话中，或者是一行中，通过一个距离算法[D] 得出一个距离系数 d，距离越近，表明两个字约有含义。例如
    "绸缪束刍，三星在隅。今夕何夕，见此邂逅？子兮子兮，如此邂逅何？"隅和夕在同一段文字中，这表明两者关系比较近。
    再比如"菁菁者莪，在彼中陵。既见君子，锡我百朋。"中的菁菁距离更近，表明更有相关性

    2. 若名字所在的那两句话的情感系数 通过一个 算法[E] 得出一个新的情感系数分 e
    例如两个字 隅夕 ，其中隅字出自 "三星在隅"，其情感系数为0.93，是个非常正向额词。夕出自"今夕何夕"，情感系数为0.5，那么加载一起
    是个不错的正向分数。
    3. 将两个名字的笔画数 通过一个算法[S] 得出一个笔画系数 s。目前的规则是，两个字加起来的笔画越少越好。笔画越少分越高
    4. 将两个名字与姓氏，通过一个相似度算法[Y] 得出一个含义系数 y。规则含义：名字与姓氏之间相似度越低越好。
    越低表明两者越不容易出现"撞车的情况"，例如：如果有个人姓"王"，那么"侯"字与王字是近义词。两个这两个字组成在一起不好听
    5. 将两个名字与姓氏，通过一个发音算法[P] 得出一个发音系数 p。含义：
    5.1 发音算法P的规则是：姓氏和名字的声母、韵母尽量避免相同。姓氏和名字避免声调一致，若3字的可以1，3同调，或者3个字都不同调。
    5.2 若两个字是叠音，只要跟姓氏不同音，就可以。
    5.3 在三个字都不同调的情况下，姓氏位置不能变，两个字的名字全排列组合再去掉声调一致的组合大致有3*3 = 9种组合。其中声调相同只适用于叠字。
        因此若不考虑叠字，则应该有A42-A21种组合，也就是说有10种组合。配合姓氏的4中声调，应该是有40中排列组合。应该针对每一个
        姓氏声调进行单独排列。这种声调矩阵，需要计算
    5.4 名字与姓氏之间的声调关系：
    12，21，13，31，14，41，23，32，34，43
1   1   2   3  4   5   6  7   8   9  10
2   1   2   3  4   5   6  7   8   9  10
3   1   2   3  4   5   6  7   8   9  10
4   1   2   3  4   5   6  7   8   9  10


    6. 将 d,e,s,y,p，通过一个算法 [N] 得出一个综合系数n
    算法N中各个系数需要通过深度学习得到
    7. n越大表明越好：优化参数和损失函数要好好设计
    超参：D,E,S,Y,P,N中的算法参数
    :param name_dim:
    :return:
    """
    pass


def _naming_loss(name_dim):
    """
    损失函数
    :param name_dim:
    :return:
    """
    pass


def _sgd(name_dim):
    """
    定义优化函数
    :param name_dim:
    :return:
    """
    pass


def _train(name_dim):
    """
    训练
    :param name_dim:
    :return:
    """
    pass
